"""
Security utilities for password hashing and JWT token management.

This module provides cryptographically secure functions for:
- Password hashing using bcrypt (cost factor 12)
- Password verification against hashed values
- JWT token creation and verification (HS256 algorithm)

All security operations follow industry best practices:
- Passwords are NEVER stored in plain text
- Bcrypt automatically handles salt generation
- JWT tokens expire after 15 minutes by default
- JWT_SECRET is loaded from environment configuration

Usage:
    from src.core.security import hash_password, verify_password
    from src.core.security import create_access_token, verify_access_token

    # Password hashing (for registration)
    hashed = hash_password("user_password")

    # Password verification (for login)
    if verify_password("user_password", stored_hash):
        # Login successful
        token = create_access_token({"sub": str(user_id)})

    # Token verification (for protected routes)
    payload = verify_access_token(token)
    if payload:
        user_id = payload["sub"]
"""

import bcrypt
from jose import jwt, JWTError
from datetime import datetime, timedelta, timezone
from typing import Dict, Optional
from calendar import timegm
import logging

from .settings import settings

# Configure logging
logger = logging.getLogger(__name__)


# JWT Configuration Constants
ALGORITHM = "HS256"
"""JWT signing algorithm (HMAC SHA-256)"""

ACCESS_TOKEN_EXPIRE_MINUTES = 15
"""Default access token expiration time in minutes"""


def hash_password(password: str) -> str:
    """
    Hash a plain text password using bcrypt with cost factor 12.

    Bcrypt automatically generates a random salt for each hash, ensuring
    that the same password will produce different hashes each time.
    Cost factor 12 provides strong security while maintaining reasonable
    performance (<100ms on modern hardware).

    Note: Bcrypt has a 72-byte password length limit. Longer passwords
    are automatically truncated to 72 bytes.

    Args:
        password: Plain text password to hash

    Returns:
        UTF-8 encoded bcrypt hash string (60 characters)

    Example:
        >>> hashed = hash_password("my_secure_password")
        >>> hashed.startswith("$2b$12$")  # Bcrypt hash format
        True
        >>> len(hashed)
        60

    Security Notes:
        - Never store plain text passwords
        - Each hash includes a random salt
        - Same password produces different hashes
        - Intentionally slow to prevent brute force attacks
        - Passwords longer than 72 bytes are truncated (bcrypt limitation)
    """
    # Encode password to bytes, generate salt with cost factor 12, hash, decode to string
    password_bytes = password.encode('utf-8')

    # Bcrypt has a 72-byte limit - truncate if necessary
    if len(password_bytes) > 72:
        password_bytes = password_bytes[:72]

    salt = bcrypt.gensalt(rounds=12)
    hashed = bcrypt.hashpw(password_bytes, salt)
    return hashed.decode('utf-8')


def verify_password(plain_password: str, hashed_password: str) -> bool:
    """
    Verify a plain text password against a bcrypt hash.

    Uses constant-time comparison to prevent timing attacks.
    Works with hashes generated by hash_password().

    Note: Automatically truncates passwords longer than 72 bytes
    to match bcrypt's hashing behavior.

    Args:
        plain_password: Plain text password to verify
        hashed_password: Bcrypt hash to compare against

    Returns:
        True if password matches hash, False otherwise

    Example:
        >>> hashed = hash_password("my_password")
        >>> verify_password("my_password", hashed)
        True
        >>> verify_password("wrong_password", hashed)
        False

    Security Notes:
        - Uses constant-time comparison
        - Returns False for any exceptions (graceful failure)
        - Never reveals why verification failed
        - Passwords longer than 72 bytes are truncated (bcrypt limitation)
    """
    try:
        password_bytes = plain_password.encode('utf-8')

        # Bcrypt has a 72-byte limit - truncate if necessary (must match hash_password behavior)
        if len(password_bytes) > 72:
            password_bytes = password_bytes[:72]

        hashed_bytes = hashed_password.encode('utf-8')
        result = bcrypt.checkpw(password_bytes, hashed_bytes)

        # Log verification outcome (info for success, warning for failure)
        if result:
            logger.info("Password verification successful")
        else:
            logger.warning("Password verification failed - incorrect password")

        return result
    except Exception as e:
        # Log exception and gracefully handle any errors
        logger.warning(f"Password verification failed - exception: {type(e).__name__}")
        return False


def create_access_token(data: Dict[str, any], expires_delta: Optional[timedelta] = None) -> str:
    """
    Create a JWT access token with HS256 algorithm.

    Tokens are signed with JWT_SECRET from settings and include an
    expiration time ('exp' claim). Default expiration is 15 minutes.

    Args:
        data: Dictionary of claims to include in token payload.
              Typically contains {"sub": user_id} for subject claim.
        expires_delta: Optional custom expiration time delta.
                      If None, uses ACCESS_TOKEN_EXPIRE_MINUTES (15 min).

    Returns:
        Signed JWT token string

    Example:
        >>> from datetime import timedelta
        >>> # Default 15 minute expiry
        >>> token = create_access_token({"sub": "user-123"})
        >>>
        >>> # Custom 1 hour expiry
        >>> token = create_access_token(
        ...     {"sub": "user-123"},
        ...     expires_delta=timedelta(hours=1)
        ... )

    Security Notes:
        - Token payload is NOT encrypted, only signed
        - Do not include sensitive data in payload
        - Tokens cannot be revoked before expiration
        - Use short expiration times for better security
    """
    # Copy data to avoid mutating the original dictionary
    to_encode = data.copy()

    # Calculate expiration time as Unix timestamp
    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)

    # Add expiration claim to payload as Unix timestamp (integer seconds since epoch)
    # Use timegm to properly convert UTC time to Unix timestamp
    to_encode.update({"exp": timegm(expire.utctimetuple())})

    # Encode and sign the token
    encoded_jwt = jwt.encode(to_encode, settings.jwt_secret, algorithm=ALGORITHM)

    # Log token creation for audit trail
    logger.info(f"Access token created with {ACCESS_TOKEN_EXPIRE_MINUTES if not expires_delta else int(expires_delta.total_seconds()/60)}min expiry")

    return encoded_jwt


def verify_access_token(token: str) -> Optional[Dict[str, any]]:
    """
    Verify and decode a JWT access token.

    Validates the token signature and expiration time.
    Returns the payload if valid, None if invalid or expired.

    Args:
        token: JWT token string to verify

    Returns:
        Dictionary containing token payload if valid, None otherwise

    Example:
        >>> token = create_access_token({"sub": "user-123"})
        >>> payload = verify_access_token(token)
        >>> payload["sub"]
        'user-123'
        >>>
        >>> # Expired or invalid token
        >>> verify_access_token("invalid.token.string")
        None

    Security Notes:
        - Returns None for ANY error (expired, invalid signature, malformed)
        - Does not reveal why verification failed
        - Checks expiration time automatically
        - Uses constant-time signature verification
    """
    try:
        # Decode and verify the token
        payload = jwt.decode(token, settings.jwt_secret, algorithms=[ALGORITHM])

        # Log successful verification
        logger.info("Access token verified successfully")

        return payload
    except JWTError as e:
        # Token is expired, invalid signature, or malformed
        # Log specific JWT error type for monitoring
        error_type = type(e).__name__
        logger.warning(f"Access token verification failed - {error_type}")
        return None
    except Exception as e:
        # Catch any other unexpected errors
        logger.warning(f"Access token verification failed - unexpected error: {type(e).__name__}")
        return None


__all__ = [
    "hash_password",
    "verify_password",
    "create_access_token",
    "verify_access_token",
    "ALGORITHM",
    "ACCESS_TOKEN_EXPIRE_MINUTES",
]
