"""
Acceptance Test-Driven Development (ATDD) Tests for Story 5.1
ConversationMessage Model & Saving

Status: RED PHASE - All tests must fail initially
Tests define expected behavior before implementation

Generated by BMad TEA Agent - Risk-based testing approach
"""

import pytest
from datetime import datetime, timezone
from uuid import UUID, uuid4
from sqlmodel import Session, select
from typing import Optional

# GIVEN: These imports will fail until implementation exists
from src.models.conversation_message import ConversationMessage  # Model doesn't exist yet
from src.models.conversation import Conversation
from src.models.user import User


class TestConversationMessageModel:
    """AC #1-2: ConversationMessage model with proper fields"""

    def test_create_conversation_message_with_required_fields(self, session: Session):
        """GIVEN a conversation exists, WHEN creating a message, THEN it should have all required fields"""
        # GIVEN: A user and conversation exist
        user = User(
            email="test@example.com",
            full_name="Test User",
            birth_date="1990-01-01",
            hashed_password="hashed"
        )
        session.add(user)
        session.commit()

        conversation = Conversation(user_id=user.id)
        session.add(conversation)
        session.commit()

        # WHEN: Creating a conversation message
        message = ConversationMessage(
            conversation_id=conversation.id,
            role="user",
            content="What's my life path number?",
            timestamp=datetime.now(timezone.utc)
        )
        session.add(message)
        session.commit()

        # THEN: Message should have all required fields
        assert isinstance(message.id, UUID)
        assert message.conversation_id == conversation.id
        assert message.role == "user"
        assert message.content == "What's my life path number?"
        assert isinstance(message.timestamp, datetime)
        assert message.message_metadata == {}  # Default empty dict

    def test_message_role_accepts_user_and_assistant(self, session: Session):
        """AC #2: Role field should accept 'user' or 'assistant' values"""
        # GIVEN: A conversation exists
        conversation_id = uuid4()

        # WHEN: Creating messages with both valid roles
        user_message = ConversationMessage(
            conversation_id=conversation_id,
            role="user",
            content="User message"
        )

        assistant_message = ConversationMessage(
            conversation_id=conversation_id,
            role="assistant",
            content="Assistant response"
        )

        # THEN: Both roles should be valid
        assert user_message.role == "user"
        assert assistant_message.role == "assistant"

    def test_message_metadata_stores_json(self, session: Session):
        """AC #2: Metadata field should store JSON data"""
        # GIVEN: A conversation exists
        conversation_id = uuid4()

        # WHEN: Creating a message with metadata
        metadata = {
            "intent": "numerology_calculation",
            "confidence": 0.95,
            "tokens_used": 150
        }

        message = ConversationMessage(
            conversation_id=conversation_id,
            role="assistant",
            content="Your life path number is 7",
            message_metadata=metadata
        )

        # THEN: Metadata should be stored as JSON
        assert message.message_metadata == metadata
        assert message.message_metadata["confidence"] == 0.95


class TestConversationMessageRelationships:
    """AC #5: Messages linked to Conversation via foreign key"""

    def test_message_has_foreign_key_to_conversation(self, session: Session):
        """GIVEN a conversation, WHEN creating a message, THEN it should link via foreign key"""
        # GIVEN: A conversation exists
        user = User(
            email="test@example.com",
            full_name="Test User",
            birth_date="1990-01-01",
            hashed_password="hashed"
        )
        session.add(user)
        session.commit()

        conversation = Conversation(user_id=user.id)
        session.add(conversation)
        session.commit()

        # WHEN: Creating a message linked to conversation
        message = ConversationMessage(
            conversation_id=conversation.id,
            role="user",
            content="Test message"
        )
        session.add(message)
        session.commit()

        # THEN: Message should be linked to conversation
        assert message.conversation_id == conversation.id
        assert message.conversation == conversation  # Relationship works

    def test_conversation_has_messages_relationship(self, session: Session):
        """AC #5: Conversation should have back-reference to messages"""
        # GIVEN: A conversation exists
        user = User(
            email="test@example.com",
            full_name="Test User",
            birth_date="1990-01-01",
            hashed_password="hashed"
        )
        session.add(user)
        session.commit()

        conversation = Conversation(user_id=user.id)
        session.add(conversation)
        session.commit()

        # WHEN: Creating multiple messages
        message1 = ConversationMessage(
            conversation_id=conversation.id,
            role="user",
            content="First message"
        )
        message2 = ConversationMessage(
            conversation_id=conversation.id,
            role="assistant",
            content="Second message"
        )
        session.add_all([message1, message2])
        session.commit()

        # THEN: Conversation should have messages relationship
        assert len(conversation.messages) == 2
        assert message1 in conversation.messages
        assert message2 in conversation.messages


class TestConversationMessageQuerying:
    """AC #6: Query messages ordered by timestamp"""

    def test_query_messages_ordered_by_timestamp(self, session: Session):
        """GIVEN multiple messages, WHEN querying, THEN results should be ordered by timestamp"""
        # GIVEN: A conversation with multiple messages
        conversation_id = uuid4()

        # Create messages with different timestamps
        older_message = ConversationMessage(
            conversation_id=conversation_id,
            role="user",
            content="First message",
            timestamp=datetime(2024, 1, 1, 10, 0, 0, tzinfo=timezone.utc)
        )

        newer_message = ConversationMessage(
            conversation_id=conversation_id,
            role="assistant",
            content="Second message",
            timestamp=datetime(2024, 1, 1, 10, 1, 0, tzinfo=timezone.utc)
        )

        session.add_all([newer_message, older_message])  # Add in reverse order
        session.commit()

        # WHEN: Querying messages ordered by timestamp
        stmt = (
            select(ConversationMessage)
            .where(ConversationMessage.conversation_id == conversation_id)
            .order_by(ConversationMessage.timestamp)
        )
        messages = session.exec(stmt).all()

        # THEN: Messages should be in chronological order
        assert len(messages) == 2
        assert messages[0].content == "First message"
        assert messages[1].content == "Second message"

    def test_filter_messages_by_conversation_id(self, session: Session):
        """AC #6: Should be able to query messages for specific conversation"""
        # GIVEN: Multiple conversations with messages
        conv1_id = uuid4()
        conv2_id = uuid4()

        msg1 = ConversationMessage(
            conversation_id=conv1_id,
            role="user",
            content="Conv1 message"
        )

        msg2 = ConversationMessage(
            conversation_id=conv2_id,
            role="user",
            content="Conv2 message"
        )

        session.add_all([msg1, msg2])
        session.commit()

        # WHEN: Querying messages for conv1
        stmt = select(ConversationMessage).where(
            ConversationMessage.conversation_id == conv1_id
        )
        conv1_messages = session.exec(stmt).all()

        # THEN: Should only get conv1 messages
        assert len(conv1_messages) == 1
        assert conv1_messages[0].content == "Conv1 message"


class TestConversationMessageTimestamps:
    """AC #8: Both user and assistant messages captured with accurate timestamps"""

    def test_message_timestamp_defaults_to_now(self, session: Session):
        """GIVEN no timestamp provided, WHEN creating message, THEN should default to current time"""
        # GIVEN: A conversation exists
        conversation_id = uuid4()

        # WHEN: Creating a message without explicit timestamp
        before = datetime.now(timezone.utc)
        message = ConversationMessage(
            conversation_id=conversation_id,
            role="user",
            content="Test message"
        )
        after = datetime.now(timezone.utc)

        # THEN: Timestamp should be set to current time
        assert before <= message.timestamp <= after

    def test_user_and_assistant_messages_have_different_timestamps(self, session: Session):
        """AC #8: User and assistant messages should have accurate, different timestamps"""
        # GIVEN: A conversation exists
        conversation_id = uuid4()

        # WHEN: Creating user and assistant messages in sequence
        user_msg = ConversationMessage(
            conversation_id=conversation_id,
            role="user",
            content="What's my destiny number?",
            timestamp=datetime(2024, 1, 1, 10, 0, 0, tzinfo=timezone.utc)
        )

        # Simulate processing time
        assistant_msg = ConversationMessage(
            conversation_id=conversation_id,
            role="assistant",
            content="Your destiny number is 8",
            timestamp=datetime(2024, 1, 1, 10, 0, 2, tzinfo=timezone.utc)  # 2 seconds later
        )

        session.add_all([user_msg, assistant_msg])
        session.commit()

        # THEN: Messages should have different, accurate timestamps
        assert user_msg.timestamp < assistant_msg.timestamp
        time_diff = (assistant_msg.timestamp - user_msg.timestamp).total_seconds()
        assert time_diff == 2.0  # 2 seconds difference


# Test Fixtures - Will be moved to conftest.py after GREEN phase
@pytest.fixture
def session():
    """Provide test database session with auto-cleanup"""
    # This fixture will fail until database is properly configured
    from src.core.database import get_test_session

    with get_test_session() as session:
        yield session
        # Auto-cleanup happens here